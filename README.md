[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15241032&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:
What is software engineering, and how does it differ from traditional programming?

Software engineering is a discipline that uses engineering concepts to create software. It's a methodical approach to software development that covers every step of the process, from design to the implementation and upkeep (del Águila, Palma & Túnez, 2014.).  Software development involves design; of which is the organising and specifying the software architecture, or how the various components will function as a whole. Development is where software developers write the code that makes the design come to life during the coding phase. Testing is whereby the careful examination of the programme takes place in order to make sure it operates as intended and to find and address any mistakes such as bugs. Maintenace is whereby engineers update and modify software in response to shifting needs and the emergence of new technologies (Al-Sarayreh, Meridji & Abran, 2021). Programming languages are the tools that software engineers use. To develop software solutions, they bring together their expertise in programming and engineering principles. Software engineering covers not just coding but the whole software lifecycle. It makes use of formal procedures such as DevOps, Waterfall and Agile. It places a focus on communication and teamwork. Thorough testing and quality inspections are part of quality assurance. Lastly, sofware engineering emphasises complete documentation and upkeep (Al-Sarayreh, Meridji & Abran, 2021). 

Software Development Life Cycle (SDLC):
Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

Software Development Life Cycle (SDLC) is an organised procedure that outlines the steps needed to create high-quality software applications.  It is divided into multiple phases, each with unique tasks and goals (Ergasheva & Kruglov, 2020). These are the common phases of SDLC;
1. Planning: this serves as the foundation. This is the stage where the project is defined, its viability evaluated, its costs approximated, and a schedule developed. 
2. Requirements Gathering and Analysis: the goal of this stage is to comprehend what the software must accomplish. In order to gather requirements, assess clients' and users' needs, and make sure everyone is in agreement, the team meets with stakeholders. 
3. Design: the architecture and user interface of the software are built with a clear understanding of the requirements. This entails drawing out a roadmap for the interopersbility of the various software components. 
4. Development: this is where the coding takes place. The software is created by developers using the design as a guide when writing the code
5. Testing: the programme is put through rigorous testing process to find and correct faults. This guarantees that the software works as intended even before users recieve it. 
6. Deployment: this is where users can get the completed software. This could entail making it accessible online or installing it on their devices. 
7. Maintenance: the software still requires regular maintenance once it is released. This entails resolving issues, incorporating fresh functionalities and maintaining software updates with security fixes. 

Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?

Waterfall phases (such as planning, designing, developing and testing) proceed in a waterfall like manner, with each step being finished before moving on to the next. It is challenging to introduce changes later in the process. It needs to be planned ahead of time and have clear requirements before work can start. This is effective when the project specifications are well-defined and unlikely to change. It also gives projects with tight deadlines and restrictions a clear strategy and predictable timeline (Kamran, Asghar, Mudassar, Ahmed, Fazal, abid, Asghar & Zameer, 2018). Whereas Agile divides development into brief iterations, or sprints and releases functional features continuously. It adjusts as the new process goes along to new requirements. It places a focus on developers and stakeholders working together. After every sprint, requirements and features can be rearranged in order of importance and modified in response to input. It also permits more rapid delivery of a working product and permits course correction in response to user input (Kelliher, BAldwin & Connell, 2001). Waterfall is preferred in projects with precise specifications, time constraints, and high-risk settings such as financial systems and medical equipment where stability is essential. Agile is preffered for projevts that emphasise innovation, have changing objectives and demand quick response such as social media platforms and mobile apps (Van Casteren, 2017). 

Requirements Engineering:
What is requirements engineering? Describe the process and its importance in the software development lifecycle.

Requirements Engineering (RE) is the process of identifying, outlining and upholding the requirements and standards for a software system of all parties involved (developers, clients and users) (Nuseibeh & Easterbrook, 2000). Its process includes;
1. Requirements Elicitation: collect data from interested parties to comprehend their requirements and anticipants. Conducting seminars, questionnaires, brainstorming sessions, and employing methods like as documents analysis and observation. Initial requirements and needs and expectations of stakeholders are recorded. 
2. Requirements Analysis: examine the collected requirements to identify any contradictions, unclear areas, or disparities. Putting requirements into categories, setting priorities and carrying out feasibility studies. Streamlined and ranked specifications that are attainable, dependable and unambiguous. 
3. Requiremnts Specifications: the agreed-upon requirements are outlined in brief and understandable texts. Use cases, user stories and system requirements are a few examples of these. 
4. Requirements Verification and Validation: this guarantees that the requirements are accurately reflected in the documentation and that they can be implemented in a practical manner (verication and validation). Methods including as reviews, prototypes and inspectiona are applied. 
5. Requirements Management: throughout the development process, requirements are continuously reviewed and updated to reflect any modifications or changes. This guarantees that everyone remains in agreement (Ozkaya, Akdur, Toptani, Kocak & Kardas, 2023). 
Requirements engineering is important because it provides a precise picture of what the software must accomplish, directing development efforts and guaranteeing that everyone is pursuing the same objective. It provides a reduced risk because early requirement identification and documentation allows for the resolution of possible problems and disputes before development starts, which lowers the risk of rework and the project. Clear communication between developers and stakeholders is facilitated by RE. Requiremnts that are documented guarantee that everyone is aware of the "what" and the "why" of the project. It provides better quality because software with clear specification is of a better calibre. User demands and expectations are more likely to be met by the finished product. Lastly it provides reduced cost because as compared to addressing issues found later in development, identifying and resolving issues early with RE saves time and money (Van Lamsweerde, 2000). 

Software Design Principles:
Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?

In software design, modularity is the process of breaking a software system up into independent, self-contained modules that each include a subset of features or functions. Every module is made to function on its own and communicate with other modules via clearly defined interfaces. This method is essential for developing software systems that are reliable, scalable and maintained (Sullivan, Griswold, Cai & Hallen, 2001). 
Modularity improves maintainability by;
1. Isolation: functionality is isolated via modules. If a bug appears, developers can concentrate on that particular module, cutting down on the amount of time spent debugging and lowering the possibility of creating new problems in other areas of the code. 
2. Focus: developers don't have to comprehend the intricacies of the complete system in order to work on certain modules. Better specialisation and increased overall development efficiency are made possible by this. 
3. Testability: independant testing is simpler for smaller, more precisely described modules. This makes it possible to test individula modules individually and their interdependencies through integration testing.   
4. Readability: because each module has a distinct purpose, modular code is usually clearer and easier to read. Both present and future developers working on the project will benefit from improved code understanding as a result. 
5. Reusabilty: reusable modules with good design can be found in other software sections or even in different projects. This cuts down on work and time spent developing. 
Modularity improves scalability by;
1. independent growth: modules can be individually changed, added, or removed as needed. As a result, the software can expand and change to meet new needs without having to start from scratch. 
2. Parallelization: parallel development, in which several teams on distinct modules at the same time, can be facilitated by modular design. For larger projects, this can greatly expedite the development process. 
3. Flexibility: by introducing new modules, new features can be added without affecting already existing functionality. This permits expansion and innovation while maintaining the stability of the core system. 
4. Distributed Systems: building large-scale distributed systems that allow distinct modules to run on different servers, hence boosting overall system performance and scalability, requires an understanding of modular design principles (Haoyu & Haili, 2012).

Testing in Software Engineering:
Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?

1. Unit Testing: The basis or foundation. Software components, such as functions and modules, are tested separately to ensure they function as intended and meet specifications. Unit tests are usually written and run by developers. 
2. Integration Testing: focuses on the interactions between several modules. To make sure the units work together and communicate effectively, they are assembled and tested. This finds problems that result from interactions between modules. 
3. System Testing: evaluates the software system as a whole. To make sure the system satisfies all functional and non-functional criteria, this entails modelling real-world scenarios and user interactions (performance, usability, security).
4. Acceptance Testing: the last obstacle before being released. Here, the software is tested by prospective users or customers (or their representatives) to see if it satisfies their acceptance requirements. This guarantees that the programme is easy to use and provides the desired results.
Testing is crucial because bugs are found and fixed ealier in the development process thanks to testing. Replacing issues found later in production using this is far faster and less expensive. Higher-quality software is the result of rigorous testing. It is more likely that the finished product will be dependable, stable and perform as planned. Software releases are less risky when they are tested (Okezie, Odun-Ayo & Bogle, 2019). By identifying possible issues in advance, you can steer clear of expensive disruptions and security flaws. Testing guarantees that the programme is easy to use and satisfies user requirements. Higher user happiness and better product adoption result from this. It also provides confidence and trust through comprehensive testing which increases trust in the functionality and dependability of the product. Both external customers and internal stakeholders need to know abot this (Kumar, 2018). 

Version Control Systems:
What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.

Tools for managing changes to source code and other documents over time are version control systems (VCS). They make it possible for several developers to collaborate on a project at once, track and merge changes, and roll back to ealier iterations as needed (Zolkifli, Ngah & Deraman, 2018). VCS allows developers to collaborate effectively by providing the a platform for several developers to callaborate on a project at the same time without intentionally erasing each other's contribution. VCS enables users to quickly go back to earlier iterations if necessary and to know who made what changes. Because VCS keeps track of all changes, it's simple to observe how the code changed over time and determine who made what changes. This is useful for troubleshooting problems and comprehending the development process of the project. Without worrying that they may ruin the project as a whole, developers can test out new features and code modifactions. If something goes wrong, they may quickly go back to a previous version that worked thanks to VCS. With the help of VCS, developers can save many codebase versions for various uses (such as testing new features and correcting bugs) (Devineni, 2019). 
Some popular VCS include: 
1. Git: the most popular VCS available today. Since the system is distributed, every developer has a full copy of the codebase on their computer. More flexibility and offline work are made possible by this. Git is renowned for its strong branching and merging capabilities, which facilitate easy cooperation on challenging projects (Loeliger & McCullough, 2012.).
2. Subversion (SVN): a centralised, older VCS where the codebase is housed on a single server. To make changes, developers check files in and out. Compare to GIT, SVN is easier to learn, but it provides fewer branching and merging flexibilit (Collins-Sussman, Fitzpatrick & Pilato, 2004). 
3. Mercurial (Hg):another distributed VCS with functionality akin to Git. it is renowned for being user-friendly and performing well with big codebases (Mercurial SCM, n.d).

Software Project Management:
Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

 A software project manager is the vital component that keeps the software development project together. They supervise the project's whole lifecycle, from inception to completion, making sure it achieves its objectives within financial and schedule limitations (Sommerville, 2016). They are responsible for planning and defining project scope, timelines and budgets, leading and motivating the development team, faciliting communication between developers, stakeholders and clients, Identifying and mitigating project risks and ensuring software quality through testing and addressing defects (Kerzner, 2017). Some challenges faced by software project managers include; scope creep, where project features and functionalities keep expanding, unrealistic deadlines that require careful time management and prioritization, limited resources that necessitate efficient allocation and delegation, communication gaps that can lead to misundrrstandings and delays and also the ever-changing technological landscape that demands flexibility and adaptation (Larson & Gray, 2017). 

Software Maintenance:
Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?

After the software is first deployed, it may need to be modified and updated to fix bugs, enhance functionality, or adjust to a new environment. This process is known as software maintenance. It is a crucial stage of the software lifecycle that guarantees the programme will satisfy user needs and continue to function well throughout time (Pressman & Maxim, 2014). The types of software maintenance activities include: 
1. Corrective maintenance: this is the firefighting activity, with an emphasis on finding and resolving mistakes or flaws that appear after the software is made available to the public. In order to restore functionality, it entails debugging problems that users have reported, revieiwing error logs, and applying patches to fix bugs
2. Adaptive maintenance: this kind of upkeep adjusts the programme to modifications in its exterior surroundings. This could involve compatibility changes, which involves updating the programme to accommodate upgrades to the operating system, hardware, or other software requirements. Regulatory compliance, involves modifying the programme to abide by new legal requirements or industry standards. Lastly, business needs changes involves, modifying features to satisfy changing user demands or corporate requirements (McConnell, 2004). 
3. Perfective maintenance: this is aimed at improving the overall efficiency, usability, and performance of the software. This could include; performance optimization, which increases the software's responsiveness, speed and resource efficiency. Usability enhancements, makes the software more user-friendly and intuitive. Introducing new features in response to customer input or shifting consumer needs. 
4. Preventative maintenance: before they cause interruptions, possible issues are found and addressed proactively. This includes code refactoring, static code analysis and regular testing (Parthasarathy, 2014).
Software maintenace is crucial because it ensures the programme stays effective, user-friendly, and adapts to changing user needs. Updates and patches on a regular basis fix security flaws and sheild user's data from online dangers (Sommerville, 2016). Updating software and addressing possible problems early on helps make it more dependable and stable. Dealing with significant disruptions or system failures later is significantly more expensive that detcting and fixing issues early through maintenance. Software may adapt and change with the help of effective maintenance, increasing its useful life and return on investment (McConnell, 2004). 

Ethical Considerations in Software Engineering:
What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

Some ethical issues that software engineers might face include:
1. Data Privacy: large volumes of user data are often handled by software engineers. Concerns about data collection, storage, use and protection raise ethical issues. One of the biggest challenges is balancing functionality with consumer privacy. 
2. Algorithmic Bias: biases in the data that algorithms are trained on have the potential to be perpetuated. Discriminatory results from this in areas such as facial recognition software, employment recommendation, and load approvals. It is imperative for engineers to acknowledge the possibility of prejudice and create algorithms that uphold equity and diversity (ACM, 2018). 
3. Security Vulnerabilities: malicious actors may use software flaws to steal information, interfere with operation, or do damage. It is the duty of engineers to develop secure code and fix vulnerabilities as soon as they arise.
4. Intellectual property: intellectual property rights must be respected. Engineers should refrain from stealing designs or code without permission. It's also essential to comprehend open-source licences and correctly attribute code that you borrow.
5. User Interface (UI) Dark Patterns: ethical issues arise from deceptive design features that induce users to perform undesired activities, such as hidden costs and misleading buttons. Transparent and user-friendly user interface designs should be the goal of software engineers (IEEE, 2020).
Software engineers can ensure they adhere to ethical standards in their work by keeping up with ethical concerns in software development. Attending pertinent workshops and reading software engineer codes of ethics might help raise awareness (ACM, 2018). When they notice possible ethical transgression, engineers should critically assess projects and voice their concerns. Having open lines of communication with management and team leads is crucial. Gaining the trust of users requires being open and honest about data gathering methods, potential biases in algorithms and security concerns (IEEE, 2020). It is the responsibility of engineers to consider the ethical consequences of their profession. Engineers who support best practices within their teams and organisation can help advance ethical software development. They can also back programmes that encourage the moral application of technology. In severe circumstance, engineers might have to decline to work on projects that have glaring ehical issues. This could be bringing up issues with higher authorities or even quitting the project altogther (ACM, 2018). 

References:

1. ACM, 2018. ACM Code of Ethics and Professional Conduct. [online] Available at: https://www.acm.org/code-of-ethics [Accessed 9 June 2024].
2. Al-Sarayreh, K.T., Meridji, K. and Abran, A., 2021. Software engineering principles: A systematic mapping study and a quantitative literature review. Engineering Science and Technology, an International Journal, 24(3), pp.768-781.
3. Collins-Sussman, B., Fitzpatrick, B.W. and Pilato, C.M., 2004. Version Control with Subversion. Sebastopol: O'Reilly Media. Available at: http://svnbook.red-bean.com/ [Accessed 9 June 2024].
4. del Águila, I.M., Palma, J. and Túnez, S., 2014. Milestones in software engineering and knowledge engineering history: A comparative review. The Scientific World Journal, 2014.
5. Devineni, S.K., 2019. Version Control Systems (VCS) the Pillars of Modern Software Development: Analyzing the Past, Present, and Anticipating Future Trends. evolution, 1, p.20.
6. Ergasheva, S. and Kruglov, A., 2020, December. Software development life cycle early phases and quality metrics: a systematic literature review. In Journal of Physics: Conference Series (Vol. 1694, No. 1, p. 012007). IOP Publishing.
7. Haoyu, W. and Haili, Z., 2012, August. Basic design principles in software engineering. In 2012 Fourth International Conference on Computational and Information Sciences (pp. 1251-1254). IEEE.
8. IEEE, 2020. IEEE Code of Ethics. [online] Available at: https://www.ieee.org/about/corporate/governance/p7-8.html [Accessed 9 June 2024].
9. Kamran, M., Asghar, R., Mudassar, M., Ahmed, S.R., Fazal, M.R., Abid, M.I., Asghar, M.U. and Zameer, M.Z., 2018. Designing and optimization of stand-alone hybrid renewable energy system for rural areas of Punjab, Pakistan. Int. J. Renew. Energy Res, 8(4), pp.2585-2597.
10. Kelliher, A., Baldwin, K., & Connell, R. (2001). Agile requirements engineering for lean development. Addison-Wesley Professional.
11. Kerzner, H., 2017. Project Management: A Systems Approach to Planning, Scheduling, and Controlling. 12th ed. Hoboken: John Wiley & Sons.
12. Kumar, A., 2018. Qualitative Analysis of Various Levels of Software Testing. international Journal of Science and Research (IJSR), (2018): 0.28
13. Larson, E.W. and Gray, C.F., 2017. Project Management: The Managerial Process. 7th ed. New York: McGraw-Hill Education
14. Loeliger, J. and McCullough, M., 2012. Version Control with Git: Powerful Tools and Techniques for Collaborative Software Development. 2nd ed. Sebastopol: O'Reilly Media.
15. McConnell, S., 2004. Code Complete: A Practical Handbook of Software Construction. 2nd ed. Redmond: Microsoft Press.
16. Mercurial SCM, n.d. Documentation. Available at: https://www.mercurial-scm.org/ [Accessed 9 June 2024].
17. Nuseibeh, B. and Easterbrook, S., 2000, May. Requirements engineering: a roadmap. In Proceedings of the Conference on the Future of Software Engineering (pp. 35-46).
18. Okezie, F., Odun-Ayo, I. and Bogle, S., 2019, December. A critical analysis of software testing tools. In Journal of Physics: Conference Series (Vol. 1378, No. 4, p. 042030). IOP Publishing.
19. Ozkaya, M., Akdur, D., Toptani, E.C., Kocak, B. and Kardas, G., 2023. Practitioners’ Perspectives towards Requirements Engineering: A Survey. Systems, 11(2), p.65.
20. Parthasarathy, M., 2014. Practical Software Maintenance: Best Practices for Managing Your Software Investment. New York: Wiley.
21. Pressman, R.S. and Maxim, B.R., 2014. Software Engineering: A Practitioner's Approach. 8th ed. New York: McGraw-Hill Education.
22. Sommerville, I., 2016. Software Engineering. 10th ed. Harlow: Pearson Education.
23. Sullivan, K.J., Griswold, W.G., Cai, Y. and Hallen, B., 2001. The structure and value of modularity in software design. ACM SIGSOFT Software Engineering Notes, 26(5), pp.99-108.
24. Van Casteren, W., 2017. The Waterfall Model and the Agile Methodologies: A comparison by project characteristics. Research Gate, 2, pp.1-6.
25. Van Lamsweerde, A., 2000, June. Requirements engineering in the year 00: A research perspective. In Proceedings of the 22nd international conference on Software engineering (pp. 5-19).

Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
